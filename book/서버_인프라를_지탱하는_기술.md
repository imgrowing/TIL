# 서버/인프라를 지탱하는 기술

## 다중화의 기본

#### 다중화란
- 다중화 (Redundancy) 란?, 장애가 발생해도 예비 운용장비로 시스템 기능을 계속할 수 있도록 하는것
- 웹서비스를 제공하는 네트워크나 서비스 에서도 가용성을 확보하기 위해 다중화 하는 것은 당연한 일이다.

#### 다중화의 본질
- 시스템의 다중화란 다음 단계를 실천한다.
1. 장애를 상정한다.
    - 다중화의 첫 걸음은 상애를 상정하는 것에서 시작
    - 라우터 장애로 서비스가 정지하거나, 서버 장애로 서비스가 정지하는 등.. 
2. 장애에 대비하여 예비 운용장비를 준비한다.
3. 장애가 발생했을 때 예비 운용장비로 교체할 수 있는 운용체제를 정비한다.

#### 라우터 장애시의 대응
- **Cold Standby** 란 ? 예비 운용장비를 보통 사용하지 않고 현재 운용장비에 장애가 발생하면 예비 운용장비로 연결하는 방식
- 라우터와 같은 네트워크 장비라면 운용중 설정을 변경하거나 저장할 데이터도 많지 않으므로 ColdStandby 방식이 현실적인 방법

#### 웹 서버 장애시의 대응
- 라우터와 마찬가지로 하면 될것 같지만 라우터와 웹 서버의 차이는 웹서버의 경우 컨텐츠가 오래되었거나, 버전이 맞지 않거나... 
- 캐시서버의 경우 충분히 캐시되지 않아 성능저하를 일으킬 수 있다. 다른 방법이 필요하다.
- **Hot Standby** 란 ? 두 대의 서버를 항상 가동시켜 두고 늘 같은 상태로 유지하는 방법이다.
> Cold Standby 의 경우 물리적인 회선연결 및 세팅시간이 필요해 다운타임이 길지만, Hot Standby의 경우 즉시 교체가 가능하다.

#### 장애 극복
- **장애 극복 (fail over)** 이란 ?현재 운용장비에 장애가 발생했을때 자동적으로 예비 운용장비로 처리를 인계하는 것
- 서버 장애를 극복하기 위해 가상 IP 주소 (Virtual IP Address) 와 IP 주소 인계를 활용한다.
- VIP를 이용한 Active/Backup 구성은 현재 운용장비인 A 서버에 VIP 1.2.3.4 를 할당해 두고 웹 서비스는 VIP 로 제공한다.
- 운용도중 장애가 발생했을 경우 VIP를 예비 운용장비인 B 서버에 할당하여 장애를 극복한다.

#### IP 주소를 인계하는 원리
- IP 주소 인계란 단순히 IP 주소를 바꿔 설정하는 것뿐 만이 아니다.
- LAN (Ethernet) 에서는 IP 주소가 아닌 NIC (Network Interface Card)에 고정적으로 할당되어 있는 MAC (Media Access Control Address)를 사용한다.
- 다른 서버에 보낼 때 MAC 주소를 얻기 위해 ARP (Address Resolution Protocol) 프로토콜을 사용한다.
    - ARP 는 IP 주소를 지정해 MAC 주소를 조회하기 위한 용도
    - 하지만 매번 조회하는건 비효율적이기 때문에 일정시간 캐싱한다.

#### 장애 검출 - 헬스체크
- **헬스체크 (Health Check)** 란? 정상적인 장애극복을 위해서는 현재 운용장비에서 장애가 발생하고 있음을 검출하는 방법이 필요하다.
- 이는 다양한 종류가 있어 적절한 것을 이용해야 한다.
1. ICMP 감시 (Layer 3)
    - ICMP의 echo 요청을 보내 응답이 오는지 체크한다. 가장 간단한 방법이지만 웹서비스가 다운된 경우 감지 불가능
    - 라우터에 의한 서비스 중지를 검출하기 위한 방법
2. 포트 감시 (Layer 4)
    - 포트 감시는 TCP로 접속을 시험해 접속가능여부를 체크한다. 웹서비스 다운 유무는 알 수 없지만 과부화 상태나 에러 반환을 감지할 수 있다.
3. 서비스 감지 (Layer 7)
    - 실제 HTTP 요청 등을 보내서 정상적인 응답이 오는지 체크한다. 대부분의 이상을 감지하지만 경우에 따라 서버에 부하를 유발할 수 있다.
    - 서버 장애에 의한 서비스 중지를 검출하기 위한 방법
> 헬스체크를 할 경우 **무엇을 확인하고자 하는가** 를 명확하게 아는것이 중요하다.

#### 부하분산
- Active/Backup 구성에서는 현재 운용장비만 접속을 처리하고 있고 예비 운용장비는 대기하고 있지만 아까운 상황이다.
- 여러대의 서버에 처리를 분산시켜 전체의 확장성을 향상시키는 방법을 부하분산 (Load Balance) 라고 한다.
- 접속자수가 늘어나서 처리가 따라가지 못하더라도 서버를 증설함으로써 대응할 수 있게 된다.

## 웹서버의 다중화 - DNS 라운드 로빈

#### DNS 라운드로빈
- DNS 를 이용해 하나의 서비스에 여러대의 서버를 분산시키는 방법
- 비교적 간단히 부하분산할 수 있는 DNS 라운드로빈 이지만 문제점이 존재한다.
1. 서버의 수 만큼 글로벌 주소가 필요하다.
2. 균등하게 분산되는 것은 아니다.
    - 모바일 기기로부터의 접속은 캐리어 게이트웨이라고 불리는 프록시 서버를 경유하는데 프록시 서버에서는 일정시간 캐싱하여 사용하므로
    - 프록시 서버를 경유하는 경우 같은 서버로 전달되는 문제가 있다.
3. 서버가 다운되어도 감지하지 못한다.

## 웹 서버의 다중화 - IPVS를 이용한 로드밸런서

#### DNS 라운드로빈과 로드밸런서의 차이
- 로드밸런서 (Load Balancer) 는 하나의 IP 주소에 대한 요청을 여러대의 서버로 분산할 수 있다.
- DNS 라운드 로빈과 다르게 글로벌 주소를 절약할 수 있음.
- 로드밸런서의 동작
    - 서비스용 글로벌 주소를 가진 가상 서버로 동작한다.
    - 클라이언트의 요청을 실제 웹서버로 분산함으로써 웹서버인것 처럼 동작한다.
- 로드밸런서의 기능
    - 여러 대의 웹서버중 한대를 선택하여 요청을 중계한다.
    - 헬스체크를 통해 정상동작중인 서버에만 요청을 중계하며, 한대가 정지 되더라도 정상 가동중인 서버가 존재하는 한 서비스가 정지하지 않는다.

#### IPVS - 리눅스로 로드밸런서 구성
- 리눅스는 별다른 소프트웨어 설치없이도 라우터로서 이용이 가능하다.
- 방화벽 등 여러 네트워크 기능들을 내장하고 있으며 **IPVS (Ip Virtual Server)** 라는 부하분산 기능을 제공하는 모듈을 포함하고 있다.

#### 로드밸런서의 종류와 IPVS의 기능
- 로드밸런서는 크게 L4와 L7 스위치 두 종류로 나뉜다.
- L4는 전송계층까지의 정보를 분석하므로 IP주소나 포트번호에 따라 분산 서버를 지정한다.
- L7은 응용계층 (애플리케이션 레이어)까지의 정보를 분석하므로 클라이언트로 부터 요청된 URL에 따라 분산대상 서버를 지정한다.

> IPVS 에 내장된 것은 L4에 해당하는 기능이다.

#### 스케쥴링 알고리즘
- IPVS에서는 몇가지 스케쥴링 알고리즘들이 있으며 주요 알고리즘 몇가지만 살펴본다.

| 명칭 | 동작 |
|---|---|
| rr(round-robin) | 순서대로 선택하며 요청을 분산한다. |
| wrr(weighted-round-robin) | rr과 같지만 가중치를 가미하여 분산한다. |
| lc(least-connection) | 접속수가 가장 적은 서버를 선택한다. 대부분의 경우 이것으로 충분하다. |
| wlc(weighted-least-connection) | lc와 같지만 가중치를 가미한다. |

#### IPVS 사용하기
- ipvsadm
- keepalived

#### ipvsadm
- IPVS를 개발한 곳에서 제공하는 명령줄 툴이다.
- 가상 서버 정의 및 리얼서버를 할당할 수 있을 뿐 아니라, 설정 내용 접속 상황 등 모니터링이 가능하다.

#### keepalived
- C언어로 작성된 데몬이다.
- /etc/keepalived/keepalived.conf 설정파일의 내용에 따라 IPVS 가상서버를 구축한다.
- 헬스체크 후 정상운용중인 서버로만 부하 분산을 진행하고, 모든 서버가 다운된 겨우 sorry_server 기능 이 있다.
- keepalived-1.1.15 에서 아래와 같은 헬스체크 기능을 제공
1. HTTP_GET
2. SSL_GET
3. TCP_CHECK
4. SMTP_CHECK
5. MISC_CHECK - 외부 명령을 실행해서 종료코드를 확인한다.

#### L4스위치와 L7스위치 - 심화
- 둘다 부하분산을 하지만 처리내용은 다르다.
- L4는 TCP 헤더 등 프로토콜의 헤더 내용을 분석하여 분산을 한다.
    - 클라이언트가 리얼서버와 TCP 세션을 전개한다.
- L7은 애플리케이션계층의 내부까지 분석하여 분산을 한다.
    - 로드밸런서와 클라이언트가 TCP 세션을 전개하고, 로드밸런서가 리얼서버와 TCP 세션을 전개하여 총 2개의 세션이 생성된다.
    
> 유연한 설정을 원한다면 L7, 성능을 추구한다면 L4 스위치를 선택

#### L4 스위치의 NAT 구성과 DSR 구성
- L4스위치는 NAT (Network Address Translation) 구성으로 이용할 수도 있지만, 성능을 추구한다면 DSR (Direct Server Return) 으로 구성할 수 있다.
- NAT 구성은 L4 스위치가 클라이언트의 요청 / 서버의 응답 두가지 모두 주소지를 변경작업을 수행한다.
- DSR 구성은 L4 스위치가 클라이언트의 요청에 대한 주소지를 변경하지 않고 서버의 응답은 클라이언트에게 직접 전송된다.

> 로드밸런서의 병목을 걱정하거나 높은 트래픽을 견디는 환경이 필요한 경우 DSR 구성을 추천한다.

- DSR 구성은 리얼서버가 글로벌 주소를 처리할 수 있어야 하며 NAT 구성에서 DSR 로 변경한다고 바로 동작하는것이 아니다.

#### 동일 서브넷인 서버를 부하분산할 경우 주의점
- 동일한 서브넷인 서버에 대해 부하분산을 할 경우 NAT 구성을 할 수 없다.
- NAT 구성에서는 로드밸런서가 목적지 IP 를 변경하기 때문에 응답이 로드밸런서로 돌아가지 않고 웹 서버로 직접 송신되는 문제가 있다.
- 이런 경우 DSR 구성으로 하는것이 좋다.

## 라우터 및 로드밸런서의 다중화

#### 다중화란
- 로드밸런서가 한대밖에 없는 상황에서는 로드밸런서가 고장날 겨우 서비스가 모두 정지해 버린다.
- 이를 SPOF (Single Point Of Failure) 단일장애점 이라고 한다. 일명 시스템의 약점인 셈이다.

#### 다중화 프로토콜 VRRP
- 어플라이언스 제품인 라우터나 로드밸런서는 독자적은 프로토콜을 사용했지만 서로 다른 벤더간 호환성 문제때문에 
- Cisco사의 HSRP (Hot Standby Routing Protocol) 기반으로 VRRP (Virtual Router Redundancy Protocol) 이 만들어 졌다.
- RFC 3768에 정의되어 있고 많은 라우터나 로드밸런서에서 사용한다.
- keepalived 에서도 이용 가능하며 설정 추가만으로도 간단하게 사용할 수 있다.

#### VRRP의 구조
- 라우터나 로드밸런서의 장애극복 원리는 웹 서버의 장애극복 절차인 헬스체크, IP 주소 인계와 동일하다.

#### VRRP 패킷
- VRRP는 마스터 노드의 가동을 감시하는 것이다.
- 마스터 노드는 정기적으로 VRRP패킷을 멀티캐스팅 주소(224.0.0.18) 로 계속해서 송신한다.
- 정상작동중임을 광고하는 메시지라는 의미로 Advertisement 라고도 한다.
- 백업 노드는 VRRP 패킷을 수신하지 못하면 마스터 노드가 다운된 것으로 판단하여 장애극복을 시작한다.
- 백업 노드가 능동적으로 마스터 노드의 상태를 확인하지는 않는다.

#### 가상 라우터 ID
- VRRP 패킷은 명확하게 정해져 있는 멀티테스킹 주소 (224.0.0.18) 로 송신됨
- 하나의 네트워크에 여러 종류의 로드밸런서를 설치한 경우 모든 VRRP패킷이 동일한 주소로 송신되어 오작동될것 같지만 그렇지 않다.
- VRRP에 존재하는 가상 라우터 ID 라는 파라메터로 인스턴스를 구분할 수 있다.

#### 우선순위(Priority)
- VRRP 구성으로 흔히 볼 수 있는것은 Active/Backup 2대로 구성한것 이지만, 구조적으로 100대의 백업노드를 가질 수도 있다.
- 이 때 문제점은 백업 노드가 2대 이상일 때 마스터 노드 정지시 어떤 백업 노드가 마스터로 승격할지 결정하는 것이다.
- 우선순위 값을 노드마다 설정하여 마스터 승격시 높은 우선순위를 갖는 노드가 마스터로 승격된다.

#### 선점형 모드(Preemptive Mode)
- VRRP의 디폴트 설정에는 기존 마스터노드 보다 높은 우선순위를 갖는 모드가 기동되면 장애 극복이 일어난다.
- 우선순위가 높은 노드가 항상 마스터 노드가 된다.

> 마스터 노드가 빈번하게 재기동을 반복하는 상황이 염려된다면 선점형 모드를 무효화하는 것이 좋다.

#### 가상 MAC 주소
- VRRP에는 가상 IP 주소와 별개로 가상 MAC 주소가 정의되어 있다.
- 장애 극복시 IP 주소 뿐 아니라 MAC 주소도 함께 인계되도록 설계되어 있다.
- IP 주소만 인계할 경우 통신 상대가 되는 모든 장비의 ARP 테이블을 변경해주어야 한다.
- 하지만 이더넷 구조상 ARP 요청이 모든 노드에 정상적으로 도달한다는 보장이 없다.
- 이를 해결하기 위해 VRRP 에서는 MAC 주소를 인계함으로 써 통신 상대가 ARP 엔트리를 갱신해야할 것을 배제한다.

#### keepalived의 구조 문제
- keepalived는 VRRP의 가상 MAC 주소를 사용하지 않는다.
- 장애 극복시 ARP 엔트리가 갱신되지 않은 장비가 존재할 경우 해당 캐시가 clear 될때까지 통신이 되지 않을 수 있다.

#### gratuitous ARP (GARP)의 지연 송신
- 위 문제를 해결하기 위해 keepalived 에는 garp_master_delay 라는 설정이 존재한다.
- 마스터가 변경된 직후에는 네트워크 상태가 불안정 하므로 어느정도 딜레이를 준 뒤 ARP 를 송신하도록 구현되어 있다.

## 리버스 프록시 도입

#### 리버스 프록시 입문
- 로드밸런서와 웹 서버 사이에 리버스 프록시 (Reverse Proxy) 라는 역할의 서버를 넣음으로써 좀 더 유연해진다.
- 리버스 프록시는 클라이언트로 부터 요청을 받아 적절한 웹 서버로 요청을 전송한다.
- 웹 서버는 요청 처리후 리버스 프록시로 반환한다.
- 중간 계층이 생기면 웹서버로 전달 도중 전/후 처리를 할 수 있다.

`장점`
1. HTTP 요청의 내용에 따라 시스템 동작제어 (L7스위치와 비슷)
2. 시스템 전체의 메모리 사용 효율 향상
3. 웹 서버가 응답하는 데이터의 버퍼링 역할

#### HTTP 요청 내용에 따른 시스템의 동작 제어
- URL, IP, User-Agent 에 따라 서로 다른 서버로 분산이 가능하다.
- 레거시 시스템을 반드시 이용해야 하는 경우 리버스 프록시로 요청 URL을 분석해 레거시 시스템이 처리가능한 URL로 변경하여 전송하는것도 가능해진다.

#### 시스템 전체의 메모리 사용효율 향상
- 정적 컨텐츠의 경우 API가 아닌 정적 컨텐츠 처리용 서버로 요청을 위임함으로써 메모리 사용 효율을 향상시킨다.

#### 웹 서버가 응답하는 데이터의 버퍼링 역할
- API 서버 앞에서 버퍼로서의 역할을 수행한다.
- HTTP의 Keep-Alive 기능 이용시 중요해 진다.
- 클라이언트와 리버스 프록시 사이에 Keep-Alive ON
- 리버스 프록시와 API 서버 간에 Keep-Alive OFF 로 설정함으로써 효율적인 운용이 가능해진다. 

## 캐시서버 도입

#### HTTP와 캐시 
- HTTP는 state-less 하다. 때문에 캐싱하기 쉽다.
- HTTP에는 프로토콜레벨에서 캐시기능이 내장되어 있다.
- 각종 브라우저 들이 갱신 여부를 판단후 캐싱된 응답을 클라이언트에게 보낸다.

#### Squid 캐시서버
- Squid 는 HTTP, HTTPS, FTP 등에서 이용되는 오픈소스 캐시서버이다.
- 클라잉너트가 서버의 문서를 다운로드한 것을 캐싱할 목적으로 이용된다.
- LAN 게이트 앞에 Squid 를 장착하고 Squid를 경우해서 접속하도록 하는 프록시 서버로 이용한다.

#### Squid 를 이용한 리버스 프록시
- 리버스 프록시로 작동시키면 서버 측의 문서를 서버 시스템측에서 Squid 로 캐싱할 수 있다.
- HTTP 내용을 캐싱하는것 뿐 아니라 다중화할 수 있다.

#### Squid 는 무서을 캐싱하는가
- HTTP 프로토콜의 캐시기능을 전제로한 캐시서버이다.
- 정적인 문서를 상당히 좋은 효율로 캐싱할수 있게 되어있다.
- 동적인 문서는 30분간 캐싱하는 등의 제어도 가능하다.
- URL을 키로 문서를 캐싱한다.

> 부하 분산을 위해 HTTP 프로토콜 레벨의 캐시에서 대응하기 힘든 경우 애플리케이션 내부에서 캐싱을 시도한다.
> DB 레코드 객체 등 객체 단위로 캐싱함으로써 대응한다.

#### memcached에 의한 캐시
- 애플리케이션 내부에서 이용하는 데이터 단위 크기로 캐시를 관리하는 캐시서버를 사용할수 있다.
- C언어로 작성된 분산 캐시서버로 스토리지는 OS의 메모리를 사용한다.
- memcached는 key,value 쌍이라면 어떤 객체든 저장할 수 있다.

## MySQL 리플리케이션 - 단시간에 장애 복구

#### DB 서버가 정지할 경우
- DB서버의 서비스가 정지하는 원인은 다음과 같다.
1. DB서버 프로세스가 비정상 종료
2. 디스크가 가득 참
3. 디스크가 고장 남
4. 서버 전원이 고장 남

#### 단시간에 복구하는 방법
- 완전히 동일한 DB서버가 두 대 있다면 한 서버가 하드웨어 고장이 나더라도 단시간 내에 복구가 가능해질 것이다.
- 리플리케이션이란 데이터를 신시간으로 다른 곳으로 복제하는것을 말한다.
- DB서버를 두 대 준비해서 데이터를 리플리케이션하면 한 서버가 고장 나더라도 단시간에 DB 서비스를 재개할 수 있게 된다.

#### MySQL 리플리케이션 기능의 특징과 주의점
- 마스터는 클라이언트로 부터 갱신, 참조 두가지 쿼리를 받아들이는 서버
- 슬레이브는 갱신 쿼리는 받지않고, 데이터 갱신은 마스터를 통해서만 하는 서버
- MySQL 리플리케이션 기능은 한대의 마스터와 여러 슬레이브로 이루어진 구성이다.

#### 비동기 데이터 복사
- MySQL에서 지원하고 있는 것은 비동기 데이터 리플리케이션 이다.
- 마스터의 갱신 처리가 슬레이브로 실시간 반영이 되지 않는다.

#### 리플리케이션된 데이터의 내용
- MySQL의 리플리케이션은 SQL문 단위로 수행된다.
- 1건이던 100건이던 갱신하는 UPDATE 문 하나만 전달된다.
- 이 방식은 송수신이 적지만, 실행 결과를 알 수 없는 쿼리를 리플리케이트 하면 백업 데이가 달라질 가능성이 있다는 위험성이 있다.

> ORDER BY 를 동반하지 않는 LIMIT을 수행할 경우 다른 행이 갱신되는 결과를 낳는 등..
> MySQL 5.1.5 이후 부터는 행 단위 리플리케이션 기능을 사용함으로써 해결된다.
> 5.1.8에서는 혼재 모드라는것이 추가되어 평소에는 SQL 문 단위, 경우에 따라 행단위 리플리케이션을 수행하는 모드이다.

#### 리플리케이션 원리
- I/O 쓰레드와 SQL 쓰레드
- 바이너리 로그와 릴레이 로그
- 포지션 정보

#### 슬레이브 I/O 쓰레드와 SQL 쓰레드
- 슬레이브에서는 리플레케이션을 위해 I/O 쓰레드와 SQL 쓰레드 두가지가 돌고있다.
- I/O 쓰레드는 마스터에서 얻은 릴레이로그 (데이터 갱신 로그) 를 파일에 기록하기만 한다.
- SQL 쓰레드는 릴레이 로그를 읽어 오로지 실행만 한다.
- 두 개의 쓰레드로 관리하는 이유는 리플리케이션 지연을 줄이기 위함이다.
- 하나의 쓰레드에서 수행할 경우 SQL 처리동안 블락되어 데이터 복제를 하지 못하게된다.

#### 바이너리 로그와 릴레이 로그
- 마스터에는 바이너리 로그, 슬레이브에는 릴레이 로그라는 파일이 생성된다.
- **바이너리 로그**는 데이터를 갱신하는 처리만 기록된다.
- 리플리케이션 외에도 풀백업에서 갱신된 내용만 보관하고자 할때도 사용한다.
- mysqlbinlog 명령을 이용해 텍스트 형식으로 변환이 가능하다.
- **릴레이 로그**는 I/O 쓰레드가 갱신로그를 수신해서 슬레이측에 저장한 것이다.
- 내용은 바이너리 로그와 동일하며, 필요가없어 질 경우 SQL 쓰레드에 의해 사라진다.

#### 포지션 정보
- 슬레이브는 리플리케이션 완료한 위치정보를 알고 있다.
- 재기동 하더라도 종료한 시점부터 데이터 리플리케이션을 재개한다.
- 마스터 호스트명, 로그 파일명, 로그 파일내에 처리한 포인트정보를 **포지션 정보** 라고 한다.
- master.info 라는 텍스트 파일로 관리되며, **SHOW SLAVE STATUS** SQL 명령어로 확인가능하다.

#### 리플리케이션의 조건
1. 마스터는 여러 슬레이브를 가질 수 있다.
2. 슬레이브는 단 하나의 마스터만 가질 수 있다.
3. 모든 마스터, 슬레이브에는 일련의 server-id를 지정해야 한다.
4. 마스터는 바이너리 로그를 출력해야 한다.
