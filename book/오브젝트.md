# 오브젝트

오브젝트 스터디 대비 정리




## 서론



### 프로그래밍 패러다임이 중요한 이유 ?



개발자 공동체가 동일한 프로그래밍 스탈와 모델을 공유할수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

동일한 규칙와 방법을 공유하는 개발자로 성장할 수 있도록 준비시킬 수있다.



프로그래밍 패러다임은 두 가지이상 패러다임이 공존할 수 있다.

하나의 언어내에서 공존함으로써 서로의 단점을 보완한다.

대표적인 예로 C++ (절차지향 + 객체지향), Scala(함수형 + 객체지향) 가 있다.

이 처럼 하나 이상의 패러다임을 수용한 언어를 다중패러다임 언어 라고 한다.



> 프로그래밍 패러다임은 혁명적 (revolutionary) 인 것이 아닌, 발전적 (evolutionary) 인 것이다.



'은총알은 없다' 라는 프레디 브룩스의 말을 기억하라. 객체지향이 적합하지 않다면 언제라도 다른 패러다임을 적용할 수 있는 시야를 기르고 지식을 갈고 닦아야 한다.





## 1장 객체, 설계





### 티켓 판매 애플리케이션



티켓 판매 애플리케이션 구현에 앞서 요구사항을 정의해 보자.



연극이나, 음악회를 공연할 수 있는 소극장을 운영중이다.

소극장을 홍보하기 위해 작은 이벤트를 기획하였다.

이벤트에 당첨된 관람객과, 일반 관람객은 각자 다른 방식으로 입장 시켜야한다.

- 이벤트 당첨 관람객은 초대장을 **티켓으로 교환** 한 뒤 입장을 해야한다.
- 당첨되지 못한 관람객은 **티켓을 구매** 한 뒤 입장을 해야한다.



`초대장 클래스`

````java
class Invitaion {
  private LocalDateTime when;
}
````



`티켓 클래스`

````java
class Ticket {
  private Long fee;
}
````



`소지품 클래스`

```java
class Bag {
  private Long amount;
  private Invitation inviation;
  private Ticket ticket;
  
  public Bag(long amount) {
    this(nul, amount);
  }
  
  public Bag(Invitation inviation, long amount) {
    this.inviation = invaition;
    this.amount = amount;
  }
  
  // ==  비즈니스 메소드 ==//
  public boolean hasInvitation() {
    return invitation != null;
  }
  
  public boolean hasTicket() {
    return ticket != null;
  }
  
  public void setTicket(Ticket ticket) {
    this.ticket = ticket;
  }
  
  public void minusAmount(Long amount) {
    this.amount -= amount;
  }
  
  public void plusAmount(Long amount) {
  	this.amount += amount; 
  }
}
```



`관람객 클래스`

````java
class Audience {
  private Bag bag;
  
  public Audience(Bag bag) {
    this.bag = bag;
  }
  
  public Bag getBag() {
    return bag;
  }
}
````



> 관람객은 소지품에 초대권, 티켓, 현금을 가질 수 있다.
>
> 관람객이 입장하기 위해서는 초대권 혹은 현금을 가지고 있어야한다.
>
> 따라서 소지품 클래스 생성시 초대권 혹은 현금을 가질수 있도록 생성자를 이용하여 제약조건을 추가하였다.



`매표소 클래스`

````java
class TicketOffice {
  private Long amount;
  private List<Ticket> tickets = new ArrayList<>();
  
  public TicketOffice(Long amount, Ticket ... tickets) {
    this.amount = amount;
    this.tickets.addAll(Arrays.asList(tickets));
  }
  
  public Ticket getTicket() {
    return tickets.remove(0);
  }
  
  public void minusAmount(Long amount) {
    this amount -= amount;
  }
  
  public void plusAmount(Long amount) {
    this.amount += amount;
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  private TicketOffice TicketOffice;
  
  public TicketSeller(TicketOffice TicketOffice) {
    this.TicketOffice = TicketOffice;
  }
  
  public TicketOffice getTicketOffice() {
    return ticketOffice;
  }
}
````



`소극장 클래스`

````java
class Theater {
  private TicketSeller ticketSeller;
  
  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }
  
  public void enter(Audience audience) {
    if (audience.getBag().hasInvitation()) {
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().setTicket(ticket);
    } else {
			Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().minusAmount(ticket.getFee());
      ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
      audience.getBag().setTicket(ticket);
    }
  }
}
````





### 소프트웨어 모듈의 3가지 목적

- 실행 중에 제대로 동작해야 한다.
- 변경을 위해 존재하는것. 변경하기 어려운 모듈은 제대로 동작 하더라도 개선해야 한다.
- 코드를 읽는 사람과 의사소통하는것. 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.





### 문제점



관람객과 판매원이 소극장의 통제를 받는 **수동적인 구조** 이다.



이해 가능한 코드란 우리의 예상에서 크게 벗어나지 않는 코드이다.

위의 구조에서는 소극장이 관람객의 가방을 뒤져 초대권을 확인 한뒤, 판매원의 티켓을 가져와 지급한다.

또한 이 코드는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다.

관람객이 가방을 가지고 있고, 가방에는 현금과 티켓이 들어 있으며, 판매원이 오피스에서 티켓을 판매하고... 이런 사실들을 모두 기억하고 있어야 한다.



> 하나의 클래스나 메서드에서 너무 많은 일을 하기 때문에 문제가 된다.
>
> 가장 심각한 문제는 관람객이나, 판매원이 변경될 경우, 소극장의 코드도 영향을 받는다는 점이다.



객체 사이의 의존성 (dependency) 와 관련된 문제이다.

의존성은 변경에 대한 영향을 암시한다. 그렇다고 객체 사이의 의존성을 완전히 없애는 것은 답이 아니다.

**최소한의 의존성만 유지** 하고 불필요한 의존성을 제거하는 것이다.



객체 간의 의존성이 과한경우 **결합도 (coupling)** 가 높다고 말한다.





### 설계 개선하기



코드를 이해하기 어려운 이유는 소극장이 **관람객의 가방과 매표소에 직접 접근** 하기 때문이다.

소극장이 관람객과 판매원에 대해 세세한 부분까지 알지 못하도록 변경하면 된다.

관람객과 판매원을 **자율적인 존재** 로 만들자.



`소극장 클래스`

````java
class Theater {
  private TicketSeller ticketSeller;
  
  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }
  
  public void enter(Audience audience) {
    ticketOffice.sellTo(audience);
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  private TicketOffice ticketOffice;
  
  public TicketSeller(TicketOffice ticketOffice) {
    this.TicketOffice = ticketOffice;
  }
  
  public void sellTo(Audience audience) {
  	ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));
  }
  
  // == 제거 == //
  public TicketOffice getTicketOffice() {
    return ticketOffice;
  }
  // == == //
}
````



`관람객 클래스`

````java
class Audience {
  private Bag bag;
  
  public Audience(Bag bag) {
    this.bag = bag;
  }
  
  public Long buy(Ticket ticket) {
    if (bag.hasInvitation()) {
      bag.setTicket(ticket);
      return 0L;
    } else {
      bag.minusAmount(ticket.getFee());
      bag.setTicket(ticket);
      return ticket.getFee();
    }
  }
  
  // == 제거 == //
  public Bag getBag() {
    return bag;
  }
  // == == //
}
````



소극장은 더이상 관람객과, 판매원에게 개입하지 않는다.

관람객과 판매원 역시 서로간의 대화를 통한 **자율적인 객체**가 되었다.



> 중요한 점은 관람객이나 판매원의 내부 구현이 변경되더라도 서로에게 영향을 주지 않는다.
>
> 수정된 코드는 변경 용이성 측면에서도 확실히 개선 되었다.





### 캡슐화와 응집도



핵심은 객체 내부의 상태를 캡슐화하고 **객체 간에 오직 메시지 (대화) 를 통해서만 상호작용 하도록 만드는 것** 이다.

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위힘하는 것을 가리켜 **응집도 (cohesion)** 가 높다고 말한다.





### 절치지향과 객체지향



소극장의 enter() 메소드는 **프로세스 (process)** 이며, 관람객, 판매원, 티켓 등은 **데이터 (Data)** 이다.

개선전 소극장의 enter() 메소드 처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 **절차적 프로그래밍(Procedural Programming)**

데이터와 프로세스가 동일한 모듈 내부에 존재하는 것을 **객체지향 프로그래밍 (Object-Oridented Programming)** 이라고 한다.



> 절치적 프로그래밍은 일반적으로 우리의 예상을 벗어나기 때문에 쉽게 읽지 못하는 코드일 확률이 높으며, 변경에 취약하다.
>
> 반면, 객체지향 프로그래밍은 객체를 **자율적인 존재**로 만들기 때문에 보다 이해하기 쉽고, 변경에 유연하다.





### 책임의 이동



절차적 프로그래밍과 객체지향 프로그래밍의 근본적인 차이를 만드는것은 **책임의 이동 (shift of responsesibility)** 이다.

절차적 프로그래밍은 소극장 (Threater) 에게 **책임이 집중**되어 있고, 객체지향 프로그래밍은 각 객체에게 **책임이 적절히 분배**되어 있다.

객체는 다른 객체와의 협력 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다.



> 설계를 어렵게 만드는 것은 **의존성**이다.
>
> 좋은 설계는 불필요한 의존성을 제거함으로 써 객체간의 **결합도**를 낮춰야한다.
>
> 이전 코드에서 선택한 방법은 각 객체 내부로 감춰 **캡슐화** 하는 방법을 사용했다.
>
> 캡슐화는 객체의 **자율성**을 높이고 **응집도** 높은 객체를 만드는 방법이다.





### 추가 개선하기



현재 설계는 이전보다 분명히 좋아졌지만, 아직 개선의 여지가 있다.



`소지품 클래스`

````java
class Bag {
  private Long amount;
  private Ticket ticket;
  private Invitation inviation;
  
  public Long hold(Ticket ticket) {
    if (hasInvitation()) {
      setTicket(ticket);
      return 0L;
    } else {
      setTicket(ticket);
      minusAmount(ticket.getFee());
      return ticket.getFee();
    }
  }
  
  private void setTicket(Ticket ticket) {
    this.ticket = ticket;
  }
  
  private boolean hasInvitation() {
    return invitation != null;
  }
  
  private void minusAmount(Long amount) {
    this.amount -= amount;
  }
}
````



`관람객 클래스`

````java
class Audience {
  public Long buy(Ticket ticket) {
    return bag.hold(ticket);
  }
}
````



`매표소 클래스`

````java
class TicketOffice {
  public void setTicketTo(Audience audience) {
    plusAmount(audience.buy(getTicket()));
  }
  
  private Ticket getTicket() {
    return tickets.remove(0);
  }
  
  private void plusAmount(Long amount) {
    this.amount += amount;
  }
}
````



`판매원 클래스`

````java
class TicketSeller {
  public void sellTo(Audience audience) {
    ticketOffice.sellTicketTo(audience);
  }
}
````



추가 개선이후, 각 객체들이 좀 더 자율적인 존재가 되었지만, 만족스러운 상황은 아니다.

그 이유는 변경 전에는 존재하지 않았던 **새로운 의존성 (매표소와 관람객)** 이 생겨났기 때문이다.



> 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
>
> 결국 설계는 **트레이드오프의 산물**이다. 모든 사람들을 만족시키는 설계란 없다.





### 의인화



현실에서는 수동적인 존재라고 하더라도 객체지향의 세계에서는 모든것이 능동적이고 자율적인 존재가 된다.

레베카 워프스브록 (Rebecca Wirfs-Brock) 은 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 **의인화 (anthropomorphism)** 라고 부른다.





### 객체지향 설계



**설계**란 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지 결정하는 과정에서 나온다.

코드 작성의 일부이며 코드를 작성하지 않고서는 검증이 불가능하다.



#### 좋은 설계 란 ?

오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계이다.





### 정리하며



요구사항은 항상 변경된다.

요구사항의 변경은 코드의 변경을 의미한다. 코드 변경시 버그가 발생할 수 있다.

우리는 변경에 유연하게 대응할 수 있는 코드가 필요하다. 변경 가능한 코드는 이해하기 쉬운 코드이다.



> 훌륭한 객체지향 설계는 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계이다.
>
> 설계는 **트레이드오프의 산물** 이다 라는 말을 기억하라


# 2장 객체지향 프로그래밍



## 영화 예매 시스템



영화와 상영영화가 있으며 사람들은 상영영화를 예매 한다는 것에 주의

특정 조건을 만족하는 사람은 요금 할인을 받을 수 있는데 이를 결정하는 **할인 조건** 과 **할인 정책** 이 있다.



할인 조건

- 순서 조건과 기간 조건 두 가지 종류가 있다.
- 순서조건은 상영 순번을 이용해 할인 여부를 결정한다.
  - 예를 들어 매일 10번째로 상영되는 영화에 할인 적용
- 기간조건은 상영 시작 시간을 이용해 할인 여부를 결정한다.
  - 예를 들어서 매주 월요일 오전 10시 시작해서 오후 1시에 종료하는 영화에 할인 적용



할인 정책

- 금액 할인 정책과 비율 할인 정책 두 가지 종류가 있다.
- 금액 할인 정책은 예매 요금에서 일정 금액을 할인해 주는 방식이다.
- 비율 할인 정책은 정가에서 일정 비율의 요금을 할인 해주는 방식이다.



| 영화                | 할인 정책              | 할인 조건                                |
| ------------------- | ---------------------- | :--------------------------------------- |
| 아바타 (10,000원)   | 금액 할인 정책 (800원) | 순번 조건 (조조)                         |
|                     |                        | 순번 조건 (10회)                         |
|                     |                        | 기간 조건 (월요일 10시 ~ 12시 사이 시작) |
|                     |                        | 기간 조건 (목요일 18시 ~ 21시 사이 시작) |
| 타이타닉 (11,000원) | 비율 할인 정책 (10%)   | 기간 조건 (화요일 14시 ~ 17시 사이 시작) |
|                     |                        | 순번 조건 (2회)                          |
|                     |                        | 기간 조건 (목요일 10시 ~ 14시 사이 시작) |
| 스타워즈 (10,000원) | 없음                   | 없음                                     |



어떤 사용자가 아바타 (10,000원) 를 예메 한다고 했을 때 의 예매 정보

| 제목      | 아바타                                |
| --------- | ------------------------------------- |
| 상영 정보 | 2019년 12월 26일 (목) 7회 18시 ~ 20시 |
| 인원      | 2명                                   |
| 정가      | 20,000원                              |
| 결재 금액 | 18,400원                              |

> 할인 조건 중 기간 조건인 목요일 18시 ~ 21시 시작 조건을 만족하므로 할인 정책 (800원)이 적용 된다.



## 협력, 객체, 클래스



진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 **객체에 초점** 을 맞춰야 한다.



어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라.

- 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

- **객체를 중심에 두는 접근 방법** 은 설계를 단순하고 깔끔하게 만든다.



객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 보라.

- 객체는 다른 객체에게 도움을 주거나 의존하며 살아가는 협력적인 존재이다.
- 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.



## 도메인의 구조를 따르는 프로그램 구조



**도메인 (domain) ** 은 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 말한다.



`영화 도메인 구조`

![스크린샷 2020-06-29 오전 7.34.52](/Users/kakaocommerce/Desktop/스크린샷 2020-06-29 오전 7.34.52.png)



### 클래스 구현



클래스를 구현하거나 클래스를 사용할 때 가장 중요한 것은 **클래스의 경계를 구분** 짓는 것이다.

훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 감추고 어떤 부분을 외부에 노출 시킬지 결정하는 것이다.

내부와 외부를 구분해야 하는 이유는 **경계의 명확성이 객체의 자율성을 보장** 하기 때문이다.



### 자율적인 객체



객체는 **상태 (state) ** 와 **행동 (behavior)** 을 함께 가지며 스스로 판단하고 행동하는 **자율적인 존재** 이다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.

1. 외부에서 접근 가능한 부분을 퍼블릭 인터페이스 (public interface)
2. 내부에서만 접근 가능한 부분을 구현 (implementation)

> 인터페이스와 구현의 분리 (separation of interface and implementation) 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙



### 프로그래머의 자유



프로그래머의 역할은 **클래스 작성자** 와 **클라이언트 프로그래머** 로 구분 할 수 있다.



클라이언트 프로그래머는 애플리케이션을 빠르고 안정적으로 구축 해야하는 것이 목표

클래스 작성자는 외부 인터페이스만 공개하고 내부 구현을 숨기는데 이를 **구현 은닉 (implementation hiding)** 이라고 부른다.

> 객체의 외부와 내부를 구분하면 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.
>
> 설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억하라.



`상영 클래스`

````java
class Screening {
  private Movie movie;
  private int sequence;
  private LocalDateTime whenScreened;
  
  public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
    this.movie = movie;
    this.sequence = sequence;
    this.whenScreened = whenScreened;
  }
  
  public Reservation(Customer customer, int audienceCount) {
    return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
  }
  
  public LocalDateTime getStartTime() {
    return this.whenScreened;
  }
  
  public boolean isSequence(int sequence) {
    return this.sequence == sequence;
  }
  
  public Money getMovieFee() {
    return this.movie.getFee();
  }
  
  private Money calcuateFee(int audienceCount) {
  	return movie.calcuateMovieFee(this).times(audienceCount);
  }
}
````



`금액 클래스`

금액 클래스를 정의함으로 써 금액과 관련된 로직과 의미를 확실하게 전달할 수 있다.

````java
class Money {
  public static final Money ZERO = Money.wons(0);
  
  private final BigDecimal amount;
  
  public static Money wons(long amount) {
    return new Money(BigDecimal.valueOf(amount));
  }
  
  public static Money wons(double amount) {
    return new Money(BigDecimal.valueOf(amount));
  }
  
  Money(BigDecimal amount) {
    this.amount = amount;
  }
  
  public Money plus(Money amount) {
    return new Money(this.amount.add(amount.amount));
  }
  
  public Money minus(Money amount) {
    return new Money(this.amount.substract(amount.amount));
  }
  
  public Money times(double percent) {
    return new Money(this.amount.multiply(BigDecimal.valueOf(percent)));
  }
  
  public boolean isLessThan(Money other) {
    return amount.compareTo(other.amount) < 0;
  }
  
  public boolean isGreaterThanOrEqual(Money other) {
    return amount.compareTo(other.amount) >= 0;
  }
}
````



`예약 클래스`

````java
class Reservation {
  private Customer customer;
  private Screening screening;
  private Money fee;
  private int audienceCount;
  
  public Reservation(Customer customer, Screening screening, Money fee, int audienceCount) {
    this.customer = customer;
    this.screening = screening;
    this.fee = fee;
    this.audienceCount = audienceCount;
  }
}
````

> 시스템의 어떤 기능을 구현하기 위해 객체들 간에 상호작용을 협력 (Collaboration) 이라고 한다.



### 협력에 관한 짧은 이야기



객체는 **메시지를 전송/수신**  함으로써 다른객체와 상호작용할 수 있으며 메시지를 수신한 객체가 자율적으로 처리할 방법을 결정하는데 이를 **메서드** 라고 부른다.



메시지와 메서드를 구분하는 것은 매우 중요하며, 메시지와 메서드의 구분에서부터 **다형성** 의 개념이 출발한다.



### 컴파일 시간 의존성과 실행 시간 의존성



**클래스 사이의 의존성** 과 **객체 사이의 의존성** 은 서로 다를 수 있다.

코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 이해하기 어려워지지만 더 유연해지고 확장 가능해 진다.

> 항상 유연성과 가독성 사이에서 고민해야 한다.
>
> 무조건 유연한 설계, 무조건 읽기 쉬운코드도 정답이 아니다.



### 차이에 의한 프로그래밍



상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.

부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍** 이라고 한다.



### 상속 과 인터페이스



인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다.

상속을 통해 자식 클래스는 부모 클래스의 인터페이스를 포함하게 된다.



### 다형성



메시지와 메서드는 다른 개념이라는 것을 기억하라.

협력하는 객체가 동일한 메시지를 던지지만, 실제 실행될 메서드를 결정하는 것은 객체의 클래스가 무엇이냐에 따라 달라지는데 이를 **다형성**  이라고 한다.



메시지와 메서드를 실행 시점에 바인딩 하는것을 **지연 바인딩** 또는 **동적 바인딩** 이라고 하고, 컴파일 시점에 바인딩 하는것을 **초기 바인딩 ** 또는 **정적 바인딩** 이라고 한다.



#### 구현 상속과 인터페이스 상속



구현 상속을 **서브 클래싱** 이라 부르고, 인터페이스 상속을 **서브 타이핑** 이라고 한다.

> 이 둘은 목적이 다르며 상속은 인터페이스 상속을 위해 사용해야 한다.



### 추상화와 유연성



추상화는 세부사항에 억눌리지 않고 도메인의 중요한 개념을 설명할 수 있다.

추상화를 이용해 기본적인 애플리케이션의 협력 흐름 기술이 가능하다.

재사용 가능한 설계의 기본인 **디자인 패턴** 이나 **프레임 워크** 모두 추상화를 이용하고 있다.



### 코드 재사용과 상속



상속은 코드를 재사용하기 위해 널리 사용되는 기법이지만 두가지 관점에서 설계에 안좋은 영향을 미친다.

1. 캡슐화를 위반한다.
2. 설계를 유연하지 못하게 만든다.



### 합성



합성은 인터페이스에 정의된 메시지만을 통해 코드를 재사용하는 방법이며, 상속이 가지는 두 가지 문제점을 모두 해결한다.

> 대부분의 설계에서는 상속과 합성을 함께 사용해야 한다.

# 3장 역할, 책임, 협력


객체지향 패러다임의 관점에서 핵심은 **역할 (role)** , **책임 (responsibililty)** , **협력 (collaboration)** 이다.

객체지향의 본질은 협력하는 **객체들의 공동체**를 창조 하는것 이다.

## 협력

영화 예매 시스템을 되돌아보면, 다양한 객체들이 영화 예매라는 기능을 구현하기 위해 메시지를 주고 받으며 상호작용하고 있다.

이런 상호작용을 **협력** 이라고  하며, 협력에 참여하기 위해 수행하는 로직을 **책임** 이라고 부른다.

협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

두 객체 간의 협력은 객체가 다른 객체에게 도움을 요청할 때 시작되는데, 이들의 유일한 커뮤니케이션 수단은 **메시지 전송**이다.

- 객체는 다른 객체의 세부 구현에 직접 접근 할 수 없기 때문에 오직 메시지 만을 통해 의사소통 할 수 있다.

어떤 객체도 섬이 아니다.[Beck89]. 객체가 필요하다면 그 이유는 단 하나여야 한다.

객체가 참여하는 협력이 객체를 구성하는 행동과 상태를 모두 결정한다.

즉 협력은, 객체를 설계하는데 필요한 일종의 **문맥 (Context)** 을 제공한다.

## 책임

협력에 참여하기 위해 객체가 수행하는 행동을 **책임** 이라고 한다.

- 객체의 책임은 크게 두 가지 범주로 나누어 세분화 하고 있다.
  1. 하는 것
     - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는것
     - 다른 객체의 행동을 시작시키는 것
     - 다른 객체의 활동을 제어하고 조절하는 것

  2. 아는 것
     - 사적인 정보에 관해 아는 것
     - 관련된 객체에 관해 아는 것
     - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

- 일반적으로 책임과 메시지의 크기는 다르다.

책임은 객체지향 설계의 핵심이다. 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에게 할당하는 것이다.

책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 설계 방식을 **책임 주도 설계 (Responsibility-Driven Design, RDD) 라고 부른다.**

객체에게 책임을 할당하는데 필요한 메시지를 식별하고, 처리할 객체를 나중에 선택하는 것이 중요하다.

다시 말하면, 객체가 메시지를 선택하는 것이 아니라 **메시지가 객체를 선택**하게 해야 한다.

- 메시지가 객체를 선택하게 해야 하는 이유 ?
  1. 객체는 **최소한의 인터페이스**를 가지게 된다.
  2. 객체는 충분히 **추상적인 인터페이스**를 가지게 된다.

객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 **상태** 에 초점을 맞추는 것이다.

객체의 세부 구현이 외부 인터페이스에 노출되므로 **캡슐화** 를 저해한다.

이런 설계 방식을  **데이터 주도 설계 (Data-Driven Design)** 라고 한다.

중요한 것은 객체의 상태가 아닌 **행동** 임을 기억하라.

## 역할

역할이 중요한 이유는 역할을 통해 **유연하고 재사용 가능한 협력**을 얻을 수 있기 때문이다.

영화 예매 도메인에서 **금액 할인 정책** 과 **비율 할인 정책** 이 존재할 때, 협력 별로 각각 구현해야할까 ?

이들은 **할인 정책** 이라는 역할로 묶을 수 있다.

여기서 역할은 두 종류의 구체적인 객체를 포괄하는 **추상화** 이다.

역할을 구현하는 가장 일반적인 방법은 **추상 클래스** 와 **인터페이스** 이다.

협력의 관점에서 구체 클래스 들이 따라야 하는 책임의 집합을 서술한 것이다.

역할은 다양한 종류의 객체를 수용할 수 있는 일종의 **슬롯** 이자, 구체적인 객체 들의 타입을 캡슐화 하는 **추상화** 이다.

역할은 객체가 참여 할 수 있는 슬롯이다.

하지만 한 종류의 객체만 협력에 참여하는 경우 역할이라는 개념을 생략하고 직접 객체를 이용해 설계하는 것이 더 좋다.

협력에 참여하는 후보가 오직 한 종류의 객체 라면 후보는 역할이 아닌 객체가 된다.

- 협력 → 역할 → 객체 → 클래스

> 역할이 중요한 이유는 동일한 협력을 수행하는 객체들을 추상화 할 수 있기 때문이다.


# 4장 설계 품질과 트레이드 오프

객체지향 설계의 핵심은 **역할** , **책임** , **협력** 이며 **책임** 이 객체지향 애플리케이션 전체의 품질을 결정한다.

훌륭한 설계는 적절한 비용 내에서 쉽게 변경할 수 있는 구조를 만드는 것이다.

객체지향 설계의 시작은, 객체의 **상태** 가 아닌 객체의 **행동** 에 초점을 맞추는 것

## 데이터 중심 설계

**데이터 중심 설계** 란, 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다.

```java
// 상품 클래스
class Product {
	// == 기본 속성들 == //
	private Long productId;
	private String name;
	private String description;
	private int price;
	...
	
	// == 할인 관련 == //
	private DiscountType discountType;
	private Bigdecimal percent;
	...

	getter, setter...
} 

// 할인 타입
enum DiscountType {
	TALK_DEAL,
	NONE,
	...
}

// 기타 등등..

// 주문 서비스
class OrderService {

	void order(Long productId, ...) {
		Product product =	find(productId);
		DiscountType = discountType = product.getDiscountType();
		
		if (dicountType == DiscountType.TALK_DEAL) {
			// getter, setter 호출..
			...
		} else {
			// getter, setter 호출..
			...
		}
	}
}
```

프로젝트의 많은 부분이 위와 같은 방식으로 되어 있다.

### 문제점

- 현재 설계는 **결합도** 가 높고, **응집도** 가 낮은 설계
  - Product와 OrderService는 **강결합** 되어 있다.
    - 할인 관련 정책이 변경 된다면 ?..
    - 퍼센트 할인이 아닌, 금액 할인 등..

- 결합도
  - 의존성의 정도
  - 다른 모듈의 세부 구현을 얼마나 알고 있나 ?
- 응집도
  - 모듈에 포함된 내부 요소들의 연관된 정도

**결합도** 가 높고, **응집도** 가 낮은 설계는 변경에 취약하다.

### 캡슐화 위반

접근 제어자 를 private 으로 설정하고, getter, setter 를 통해 접근한다고 해서 캡슐화 원칙을 지키는 것은 아니다. 

getXXX(), setXXX() 와 같이 내부의 property 를 외부에 노골적으로 노출하고 있는것 과 동일하다.

이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 **추측에 의한 설계 전략 (design-by-guessing strategy)** 라고 한다.

### 높은 결합도

Product의 할인 관련 구현이 변경되면, 이를 사용하는 OrderService 도 함께 변경되어야 한다.

### 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈 내에 존재할 때, 응집도 가 낮다고 표현한다.

> 현재의 설계는 할인 관련 정책을 수정하기 위해, Product가 수정 되어야 하며, Product가 수정되면 OrderService 도 영향을 받는다.

### 단일 책임 원칙 (Single Responsibility Principle, SRP)

[객체 지향 프로그래밍](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)에서 **단일 책임 원칙**(single responsibility principle)이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 [캡슐화](https://ko.wikipedia.org/wiki/%EC%BA%A1%EC%8A%90%ED%99%94) 해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다.

## 정리

- 데이터 중심 설계가 변경에 취약한 이유
  - 객체의 행동보다 상태에 초점을 맞춘다.
    - 설계를 시작할 때 객체가 가지는 **데이터** 를 먼저 정의한다.
    - **절차적 프로그래밍** 을 따르고 있다.

  - 객체를 고립시킨 채 오퍼레이션을 정의한다.
    - 초점이 객체의 외부가 아닌, 내부이다.
    
    
# 5장 책임 할당하기

책임에 초점을 맞춰 설계할 때 가장 큰 어려움은 **어떤 객체에게 어떤 책임을 할당할 것인가**  이다.

**GRASP 패턴** 은 책임 할당의 어려움을 해결하기 위한 답을 제시해 준다.

## 책임 주도 설계

- 책임 주도 설계로 전환하기 위한 두가지 원칙
  - 데이터 보다 행동을 먼저 결정하라
  - 협력이라는 문맥 내에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라

객체의 행동이 아닌 데이터에 초점을 맞추면 객체의 **캡슐화** 가 약화된다.

그에 따라 **낮은 응집도와 높은 결합도** 를 가진 객체를 만들게 된다. 이는 변경에 취약한 설계이다.

객체지향 설계에서 가장 중요한 것은 적절한 객체에게 적절한 책임을 할당하는 능력

### 협력이라는 문맥 내에서 책임을 결정하라

객체 간의 협력은 **메시지** 를 통해 이루어진다.

메시지를 전송하는 클라이언트의 의도에 적합한 **책임** 을 할당 해야 한다.

객체를 결정한 뒤 메시지를 선택 하는 것이 아닌, 메시지를 결정한 후에 객체를 선택 해야 한다.

## GRASP 패턴

GRASP (General Responsibility Assignment Software Pattern) 은 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.

### Information Expert Pattern

책임을 수행할 정보를 알고 있는 객체에게 책임을 할당 하라.

정보와 행동을 최대한 가까운 곳에 위치시켜 캡슐화를 유지하라.

여기서 말하는 **정보** 는 데이터 와는 다르다는 점에 주의하라. 해당 정보를 제공할 객체를 알고 있거나 필요한 정보를 계산하여 제공할 수 있다.

### Low Coupling Pattern

설계의 전체적인 **결합도** 가 낮게 유지되도록 책임을 할당하라.

### High Cohesion Pattern

높은 **응집도** 를 유지할 수 있게 책임을 할당하라.

### Creator Pattern

객체와 연결되거나 관련될 필요가 있는 객체에게 해당 객체를 생성할 책임을 맡겨라.

해당 객체에 대해 잘 알거나 객체를 사용 해야 하는 객체는 어떤 방식으로든 결합된다.

### Polymorphism Pattern

타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 **책임** 을 할당하라.

### Protected Variations Pattern

변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.

# 6장 메시지와 인터페이스

객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아닌 객체들이 주고받는 **메시지** 이다.

애플리케이션은 클래스로 구성되지만, 메시지를 통해 정의된다는 사실을 기억하라.

## 협력과 메시지

두 객체 사이의 협력관계를 설명하기 위해 사용하는 전통적인 메타포는 **클라이언트-서버** 모델 이다.

객체는 협력에 참여하는 동안 클라이언트와 서버의 역할들 동시에 수행하는 것이 일반적이다.

협력의 관점에서 메시지는 두 가지 종류로 구성된다.

1. 외부 객체에게 전송하는 메시지
2. 객체가 수신하는 메시지

메시지는 **오퍼레이션명** 과 **인자** 로 구성된다.

**퍼블릭 인터페이스** 는 객체가 의사소통을 하기위해 외부에 공개하는 메시지 집합이다.

퍼블릭 인터페이스에 포함된 메시지를 **오퍼레이션** 이라고 한다.

**메서드** 는 메시지가 수신되었을 때 실제로 실행되는 함수 혹은 프로시저이다.

## 인터페이스와 설계 품질

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스 이다.

이를 설계하기 위한 가장 좋은 방법은 **책임 주도 설계** 이다.

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

### 디미터 법칙 (Law of Demeter)

객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.

극단적으로 표현하면 오직 하나의 도트만을 사용하라.

**부끄럼 타는 코드 (shy code)** 를 작성할 수 있다.

- 불필요한 어떤 것도 다른 객체에게 보여주지 않는다.
- 메시지 수신자의 내부 구조가 전송자 에게 노출되지 않는다.

아래와 같은 코드를 **기차 충돌** 이라고 부른다.

```java
member.getTeam().getName();
```

### 묻지 말고 시켜라

훌륭한 메시지는 객체의 상태에게 관해 묻지 말고, 원하는 것을 시켜야 한다.

메시지 전송자는 메시지 수신자의 상태를 기반으로 결정 내린뒤 메시지 수신자의 상태를 변경해서는 안된다. 이는 **캡슐화 위반** 이다.

### 의도를 드러내는 인터페이스

켄트 백은 메서드 명명하는 두가지 방법을 제시했다.

1. 메서드가 작업을 어떻게 수행하는지 표현한다.
2. **무엇을**  하는지 표현한다.

첫 번째 방법은 메서드의 내부 구현 방법을 드러내기에 좋지 않은 방법이다.

이는 메서드 수준에서의 캡슐화를 위반한다.

두 번째 방법은 코드를 읽고 이해하기 쉽게 만들 뿐 아니라 유연한 코드를 낳는 지름길이다.

이런 방법을 **의도를 드러내는 선택자** 라고 부른다.

### 명령-쿼리 분리 원칙

어떤 절차를 묶어 호출이 가능하도록 만든 모듈을 **루틴** 이라고 한다.

루틴은 **프로시저** 와 **함수** 로 구분할 수 있다.

1. 프로시저는 부수효과를 발생시킬 수 있지만 반환값이 없다.
2. 함수는 반환값이 존재하지만 부수효과를 발생시킬 수 없다.

명령-쿼리 분리 원칙의 요지는 오퍼레이션은 Command or Query 둘 중 하나 여야만 한다.

명령-쿼리 분리요칙을 지킴으로써 제한적인 **참조 투명성** 의 혜택을 누릴 수 있다.

### 원칙의 함정

설계를 적절하게 트레이드 오프 할 수 있는 능력이 숙련자와 초보자를 구분하는 가장 중요한 기준이다.

현재 상황에 부적합하다면 과감하게 원칙을 무시하라.

원칙을 아는것 보다 언제 유용하고 유용하지 않은지 판단하는 능력이 더 중요하다.

### 책임에 초점을 맞춰라

메시지를 먼저 선택하고 메시지를 처리할 객체를 선택하라.

훌륭한 메시지를 얻기 위한 출발점은 **책임 주도 설계 원칙**을 따르는 것이다.

# 7장 객체 분해

## 프로시저 추상화와 데이터 추상화

현대적인 프로그래밍 언어를 특징 짓는 것은 **프로시저 추상화** 와 **데이터 추상화 이다.**

프로시저 추상화는 소프트웨어가 **무엇을 해야 하는지,** 데이터 추상화는 소프트웨어가 **무엇을 알아야 하는지** 를 추상화 한다.

프로시저 추상화는 **기능 분해** 혹은 **알고리즘 분해** 라고 한다.

데이터 추상화는 **타입 추상화** 와 **프로시저 추상화** 가 있다.

타입추상화는 **추상 데이터타입** 이라고 하며, 프로시저 추상화는 **객체지향** 이라고 부른다.

## 프로시저 추상화와 기능 분해

전통적인 기능 분해는 **하향식 접근법** 을 따른다.

시스템을 구성하는 가장 최상위 기능을 정의한 뒤, 이 기능을 점점 작은 단위로 쪼개는 것을 말한다.

하향식 접근법은 이상적인 방법 처럼 보일 수 있지만, 다양한 문제점이 있다.

1. 시스템은 하나의 메인 함수로 구성되지 않는다.
2. 변경에 취약하다.
3. 비즈니스 로직과 인터페이스가 강결합 되어 있다.
4. 너무 이른 시기에 실행 순서를 정한다. 유연성과 재사용성이 저하된다.
5. 데이터 형식 변경시 파급효과 예측이 불가능하다.

종합하면 결국 **변경에 취약** 한 설계라는 것이다.

## 정보 은닉과 모듈

**정보 은닉** 은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 인터페이스 뒤로 감추는 것이 핵심이다.

모듈은 **복잡성** 과 **변경 가능성** 의 비밀을 감춰야 한다.

- 복잡성
    - 외부에 모듈을 추상화할 수 있는 인터페이스를 제공하여 복잡도를 낮춰야 한다.
- 변경 가능성
    - 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않는 인터페이스만 노출한다.

### 모듈의 장점과 한계

- 장점
    1. 모듈 내부의 변수가 변경 되더라도 모듈 내부에만 영향을 미친다.
    2. 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
    3. 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.
- 한계
    - 인스턴스의 개념을 제공하지 않는다.

## 데이터 추상화와 추상 데이터 타입

프로그래밍 언어에서 **타입 (type)** 이란 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.

프로그래밍 언어는 다양한 형태의 내장 타입을 제공한다.

**추상 데이터 타입을 구현하기 위한 조건**

1. 타입 정의 선언이 가능해야 한다.
2. 타입의 인스턴스를 다루기 위해 사용 가능한 오퍼레이션의 집합 정의가 가능해야 한다.
3. 캡슐화가 가능해야 한다.
4. 타입에 대해 다수의 인스턴스 생성이 가능해야 한다.

## 클래스는 추상 데이터 타입인가

대부분의 프로그래밍 서적에서는 클래스를 추상 데이터 타입으로 설명하지만, 명확한 의미에서 이는 동일하지 않다.

핵심적인 차이는 클래스는 **상속과 다형성** 을 지원하지만, 추상 데이터 타입은 지원하지 못한다.

상속과 다형성을 지원하지 않는 추상 데이터 타입 기반 프로그래밍 기법을 **객체 기반 프로그래밍** 이라고 부른다.

추상 데이터 타입은 **타입을 추상화** 한 것, 클래스는 **절차를 추상화** 한 것이다.

### 타입 추상화

정규 직원과 아르바이트 직원 이라는 두개의 타입이 존재할 때, 직원 (Employee) 라는 하나의 대표적인 타입으로 추상화 하는 것 이다.

타입 추상화는 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법이다.

### 객체지향 추상화

객체지향은 타입을 기준으로 오퍼레이션을 묶는다.

정규 직원과 아르바이트 직원 두 개의 타입을 명시적으로 정의 한 뒤 해당 유형에 알맞은 오퍼레이션의 실행 절차를 두 타입에 분배한다.

## 변경을 기준으로 선택해라

새로운 타입을 빈번하게 추가해야 한다면 객체지향 클래스 구조가 더 유용하다.

반면 새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상 데이터 타입을 선택하는 것이 현명한 판단이다.

# 8장 의존성 관리하기

# 서론

객체지향은 객체들 간의 **협력** 으로 이루어진다.

협력은 객체가 다른 객체에 대해 알것을 강요하며, 객체가 수신 가능한 메시지에 대해 알고 있어야하는데

이런 지식이 객체 간의 **의존성** 을 만든다.

**과도한 의존성** 은 애플리케이션을 수정하기 어렵게 만들며, 객체 지향 설계의 핵심은 변경을 방해하는 의존성을 제거하는 것이다.

## 의존성 이해

의존성은 **실행 시점** 과 **구현 시점** 두 가지가 존재하며, 서로 다른 의미를 가진다.

- 실행 시점: 의존하는 객체가 정상 동작하기 위해 실행 시 의존 대상 객체가 반드시 존재 해야 함
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경됨

**의존성 전의 (transitive dependency)** 는 객체 A에 의존하는 객체는 A가 의존하는 대상에도 자연스레 의존하게 된다는 의미

의존성의 종류는 **직접 의존성 (direct dependency)** 과 **간접 의존성 (indirect dependency)** 두 가지로 나뉜다.

- 직접 의존성: 한 요소가 다른 요소에 직접 의존 하는 경우 (코드에 명시적으로 나타남)
- 간접 의존성: 의존성 전이에 의해 전파되는 경우 (코드에 명시적으로 나타나지 않음)

**변경** 과 관련 된 모든 것들이 의존성 개념이 적용되며, 의존성이란 의존하고 있는 대상의 **영향을 받을 수 있는 가능성** 이다.

의존성은 다시 **런타임 의존성 (run-time dependency)** 와 **컴파일 타임 의존성 (compile-time dependecy)** 로 나뉜다.

- 런타임 의존성: 애플리케이션 실행 시점
- 컴파일 타임: 작성된 코드를 의미

![8%2064cd76ea9e864988a11769763234bc48/_2020-07-20__8.37.46.png](8%2064cd76ea9e864988a11769763234bc48/_2020-07-20__8.37.46.png)

컴파일 타임 의존성

![8%2064cd76ea9e864988a11769763234bc48/_2020-07-20__8.39.43.png](8%2064cd76ea9e864988a11769763234bc48/_2020-07-20__8.39.43.png)

런타임 의존성

유연한 설계를 위해서는 자신이 실행될 **컨텍스트** 에 대한 정보가 적어야 한다.

컨텍스트에 대한 정보가 적을수록 여러 컨텍스트에서 재사용 될 수 있다. 이를 **컨텍스트 독립성** 이라고 한다.

컴파일 타임의 의존성을 적절한 런타임 의존성으로 교체하는 것을 **의존성 해결** 이라고 하는데, 이를 해결하는 방법은 세가지가 있다.

1. 생성자를 통한 방법
2. 객체 생성후 setter를 통한 방법
3. 메서드 실행시 인자를 해결하는 방법

위 세가지 방법 모두 의존성이 명시적으로 퍼블릭 인터페이스에 노출되는데, 이를 **명시적인 의존성 (explicit dependecy** 라고 한다.

반대로, 의존성이 퍼블릭 인터페이스에 노출되지 않는다면, **숨겨진 의존성 (hidden dependecy)** 라고 한다.

유연한 설계를 위해서는 **명시적인 의존성** 을 사용해야 한다.

명시적인 의존성을 사용해야만 설계가 유연하고 재사용 가능해 진다.

## 유연한 설계

결합도의 정도는 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정되며, 바람직한 의존성은 **느슨한 결합도 (loose coupling)** , 바람직하지 못한 의존성은 **강한 결합도 (string coupling)** 이라고 표현한다.

느슨한 결합을 위해서는 **추상화** 에 의존해야 한다.

추상화와 결합도의 관점에서의 의존성은 다음 세 가지로 구분할 수 있다.

1. 구체 클래스 의존성 (concrete class depㅔ
2. 추상 클래스 의존성 (abstarct class dependecy)
3. 인터페이스 의존성 (ㅑㅜㅅㄷ

위 세가지 중 아래로 갈 수록 결합도가 느슨해지는데, 이는 의존 대상이 **추상적** 일수록 결합도는 더 낮아진다는 것이다.

객체 내부의 **new 키워드를 경계해라** 이는 결합도를 높힐 가능성이 있다.

- 모든 것에 예외는 있다. 표준 클래스는 문제가 되지 않는다.

## 정리

유연하고 재사용 가능한 설계

- 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는것
- 객체들의 조합을 통해 무엇 (what) 을 하는지 표현하는 클래스 들로 구성됨

# 9장 유연한 설계

# 개방 - 폐쇄의 원칙

로버트마틴이  고안한 **개방-폐쇄의 원칙 (Open-Closed Principle, OCP)** 는 다음으로 요약할 수 있다.

소프트 웨어 개체 (클래스, 모듈, 함수 등) 는 확장에 대해 열려 있어야하고, 수정에 대해 닫혀 있어야 한다.

## 컴파일 타임 의존성을 고정하고, 런타임 의존성을 변경하라

개방-폐쇄의 원칙을 런타임 의존성과 컴파일 의존성에 대한 이야기 이다.

개방-폐쇄의 원칙을 따르는 코드는 컴파일 타임 의존성을 수정하지 않고도, 런타임 의존성을 쉽게 변경할 수 있다.

Movie 클래스가 DiscountPolicy 라는 추상화에 의존하는 한 새로운 할인 정책이 추가 되더라도 컴파일 의존성은 변경되지 않는다.

## 추상화가 핵심

개방-폐쇄의 원칙의 핵심은 **추상화** 이다.

**추상화** 란 핵심적인 부분만 남겨두고 불필요한 부분은 생략함으로 써 복잡성을 극복하는 기법이다.

# 생성 과 사용의 분리

추상화에만 의존하기 위해서는 내부에서 추상화된 클래스의 **구체 클래스 인스턴스를 생성해서는 안된다.**

구체 클래스의 인스턴스를 내부에서 생성하게 될 경우 **결합도**가 높아진다.

결합도가 높아질수록 개방-폐쇄 원칙 구조를 설계하기 힘들어진다.

유연하고 재사용 가능한 설계는 객체를 **생성하는 책임과, 사용하는 책임을 분리**해야 한다.

## FACTORY 추가하기

객체의 생성과 관련된 책임만 전담하는 객체를 **FACTORY** 라고 한다.

Factory를 사용하면 객체 내부에서 구체 클래스의 인스턴스를 생성하는 책임이 Factory에게 이동된다.

순수한 가공물에게 책임 할당하기

FACTORY는 도메인 모델에 속하지 않는다.

크레이그 라만은 시스템을 객체로 분해하는데는 두가지 방식이 있다고 설명한다.

**표현적 분해 (representational decomposition)** 과 **행위적 분해 (behavioral decomposition)** 이다.

표현적 분해는 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것이다.

이는 객체지향 설계를 위한 가장 기본적인 접근법이다.

어떤 행동을 추가하려고 하는데 이를 책임질 만한 도메인이 존재하지 않는다면 **PURE FABRICATION (순수한 가공물)** 에게 이를 할당하라.

**PURE FABRICATION 패턴**

정보 전문가 패턴에 따라 책임을 할당한 결과가 바람직하지 않은 경우 대안으로 사용된다.

객체가 책임을 수행하는 필요한 많은 정보를 가지고 있지만, 해당 책임을 할당할 경우 결합도가 높아진다면 가공의 객체를 추가해서 책임을 옮기는 것을 고민하라.

# 의존성 주입

**의존성 주입 (dependency injection)** 은 사용하는 객체가 아닌 외부의 독립 적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법 이다.

의존성을 해결하는 방법은 3가지가 있다.

1. 생성자 주입: 객체 생성 시점에 생성자를 통한 의존성 해결
2. setter 주입: 객체 생성 후 setter 메서드를 통한 의존성 해결
3. 메서드 주입: 메서드 실행시 인자를 활용한 의존성 해결

## SERVICE LOCATOR 패턴

의존성 주입 외에 의존성을 해결할 수 있는 다양한 방법들이 있는데, 그중 가장 널리 사용 되는 방법이다.

SERVICE LOCATOR 는 의존성을 해결할 객체 들을 보관하는 일종의 저장소 이다.

외부로 부터 주입 받는 것이 아닌, 객체가 직접 SERVICE LOCATOR 에게 의존성을 해결해 줄 것을 요청한다.

단점은 의존성을 감춘다는 것이다. 퍼블릭 인터페이스의 어디에도 이 의존성에 대한 정보가 표시되어 있지 않기 때문에 숨겨진 의존성이라고 표현한다.

## 의존성 역전 원칙

상위 수준의 모듈을 하위 수준의 모듈에 의존해서는 안된다. 모두 추상화에 의존해야 한다.

추상화는 구체적인 사항에 의존해서는 안된다. 이는 추상화에 의존해야 한다.

이를 **의존성 역전의 원칙 (dependency inversion principle, DIP)** 라고 한다.

## 유연한 설계는 유연성이 필요할 때만 옳다.

불필요한 유연성을 불필요한 복잡성을 낳는다. 단순하게 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라.

## 협력과 책임이 중요하다.

결국 협력과 책임이 중요하다. 설계를 유연하게 만들기 위해서는 역할, 책임, 협력에 초점을 맞추어야 한다.

다양한 컨텍스트에서 재사용할 필요가 없다면, 설계를 유연하게 만들 당위성도 사라진다.

# 10장 상속과 코드 재사용

# 서론

객체지향 프로그래밍의 장점중 하나는 코드를 재사용하기 용이하다는 점이다.

클래스를 재사용하기 위한 대표적인 기법인 **상속** 에 대해 살펴본다.



# 상속과 중복 코드

**DRY 원칙** 는 반복 하지마라, Don't Repeat Yourself 의 첫 글자를 모아 만든 용어이다.

- 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 믿을만한 표현 양식을 가져야 한다.

**상속을 위한 경고1** 

- 자식 클래스의 메서드 내에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출하면 두 클래스는 강하게 결합된다.

상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 **취약한 기반 클래스 문제** 라고 한다.

이는 코드 재사용을 목적을 상속을 사용할 때 발생하는 가장 대표적인 문제이다.

취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높힌다.

상속을 사용하면 부모 클래스의 퍼블릭 인터페이스가 아닌 구현을 변경하더라도 자식클래스가 영향을 받기 쉬워진다.

## 불필요한 인터페이스 상속 문제

자바 초기버전에서 상속을 잘못 사용한 대표적인 사례는 java.util.Properties, java.util.Stack 이다.

두 클래스 모두 부모 클래스에서 상속받은 메서드를 사용할 경우, 자식 클래스의 규칙이 위반 될 수 있다.

**상속을 위한 경고 2** 

- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

## 메서드 오버라이딩의 오작용 문제

이펙티브 자바에서 HashSet 구현에 강하게 결합된 InstrumentedHashSet 클래스를 소개한다.

- 자식 클래스에서 오버라이딩한 결과가 부모클래스의 메서드에 까지 영향을 미친다.

**상속을 위한 경고 3**

- 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

## 부모 클래스와 자식 클래스의 동시 수정 문제

결합도란 다른 대상에 대해 알고 있는 지식의 양이다.

코드 재사용을 위한 상속은 부모 클래스와 자식 클래스를 강결합 시키기 때문에 **함께 수정해야 하는 상황** 이 빈번하게 발생할 수 있다.

**상속을 위한 경고 4**

- 클래스를 상속하면 결합도로 인해 둘 모두 변경하지 않거나, 둘 모두 변경하거나 선택을 해야 한다.

## 추상화에 의존하라

강결합을 해결하는 가장 일반적인 방법은 부모 클래스와 자식 클래스 모두 추상화에 의존 하게 만드는 것이다.

## 코드 중복 목적의 상속을 사용할 때 두가지 원칙

1. 두 메서드가 유사해 보인다면 차이점을 메서드로 추출하라.
2. 부모 클래스의 코드를 하위로 내리지 말고, 자식 클래스의 코드를 상위로 올려라.

# 차이에 의한 프로그래밍

**차이에 의한 프로그래밍** 이란 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법이다.

목표는 중복 코드를 제거하고 코드를 재사용하는 것이다.

상속은 코드 재사용과 관련된 대부분의 경우에 우아한 해결방법이 아니다.

더 좋은 방법은 **합성** 이다.

# 12장 다형성

# 서론

코드 재사용을 목적으로 상속을 사용해서는 안된다.

상속은 타입 계층을 구조화 하기 위해 나온것 이다.

타입 계층은 객체지향 프로그래밍의 특성중 하나인 다형성의 기반을 제공해 준다.



# 다형성

객체지향 프로그래밍에서 사용되는 다형성은 **유니버설 다형성** 과 **임시 다형성** 으로 분류

유니버셜은 **매개변수 다형성** 과 **포함 다형성** 으로 분류하고, 임시 다형성은 **오버로딩 다형성** 과 **강제 다형성** 으로 분류가 가능하다.

**매개변수 다형성 (Parametic)** 은 제네릭 프로그래밍과 관련이 높다.

클래스의 인스턴스 변수나 메서드 매개변수 타입을 임의의 타입으로 선언한 뒤 사용 시점 에 구체적인 타입을 결정하는 방식

**포함 다형성 (Inclustion)** 은 서브타입 다형성이라고도 불린다.

메시지가 동일하더라도 수신한 객체의 타입에 따라 행동이 달라지는 객체지향 프로그래밍의 가장 대표적인 형태

일반적으로 다형성이라고 하면 이 포함 다형성을 말한다.

**오버로딩 다형성 (Overloading)** 은 일반적으로 하나의 클래스 내에서 동일한 이름의 메서드가 존재하는 경우를 가리킨다.

**강제 다형성 (Coercion)** 은 언어 레벨에서 지원하는 자동 타입 변환 등을 활용해 연산자를 다양한 타입에 사용 가능한 방식을 말한다. 

자바에서 대표적인 예는 "string" + 1 = "string1" 과 같다.

# 상속의 양면성

객체지향 패러다임의 근간은 데이터와 행동을 객체라고 불리는 **하나의 실행 단위로 통합**하는 것

**데이터 관점** 의 상속은 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 포함 시킨다.

**행동 관점** 의 상속은 부모클래서 정의한 일부 메서드를 자동으로 자식 클래스에 포함 시킨다.

재사용 매커니즘 처럼 보이지만, 상속의 목적은 코드 재사용이 아니다.

상속은 프로그램을 구성하는 개념들을 기반으로 **다형성** 을 가능하게 하는 **타입 계층** 구축이 목적이다.

## 상속의 매커니즘을 이해하기 위한 5가지 개념

1. 업캐스팅
2. 동적 메서드 탐색
3. 동적 바인딩
4. self 참조
5. super 참조

**업 캐스팅**

- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스 할당하는것이 가능한 것
- 반대는 다운 캐스팅 이라고 한다.

**동적 메서드 탐색**

- 자동적인 메시지 위임 - 자신이 이해할 수 없는 메시지를 받은 경우 상속 계층을 따라 부모 에게 위임한다.
- 동적인 문맥 사용 - 어떤 메서드를 실행할지 런타임에 결정된다.

**동적 바인딩**

- 선언된 변수의 타입이 아닌 **메시지를 수신하는 객체의 타입**에 따라 실행되는 메서드가 결정되는 것
- 실행 될 메서드를 **런타임에 결정**한다.

**self 참조**

- 객체가 메시지를 수신하면 컴파일러는 self 참조 라는 임시 변수를 자동으로 생성한 뒤 **메시지를 수신한 객체를 가리키게 한다.**
- 가장 큰 특징은 **동적** 이라는 것

**super 참조**

- self 참조가 현재 객체를 가리킨다면 , super참조는 현재 클래스의 **부모 클래스 부터 메서드 탐색을 시작하라** 는 의미
